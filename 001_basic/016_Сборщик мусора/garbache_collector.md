# Сборка мусора

## Основы сборки мусора

[Сборка мусора](http://msdn.microsoft.com/ru-ru/library/0xy59wtx.aspx)
Сборщик мусора .NET управляет выделением и освобождением памяти для приложения. При каждом создании объекта среда CLR выделяет память для объекта из управляемой кучи. Пока в управляемой куче есть доступное адресное пространство, среда выполнения продолжает выделять пространство для новых объектов. Тем не менее ресурсы памяти не безграничны. В конечном счете сборщику мусора необходимо выполнить сбор, чтобы освободить память. Механизм оптимизации сборщика мусора определяет наилучшее время для выполнения сбора, основываясь на выполненных операциях выделения памяти. Когда сборщик мусора выполняет сборку, он проверяет наличие объектов в управляемой куче, которые больше не используются приложением, а затем выполняет необходимые операции, чтобы освободить память.

### Выделение ресурсов из управляемой кучи

В CLR память для всех ресурсов выделяется из управляемой кучи (manage heap). При инициализации процесса CLR резервирует область адресного пространства под управляемую кучу, а так же указатель, который определяет где в куче будет выделена память для следующего объекта, и изначально указывает на базовый адрес этого адресного пространства.
При создании объекта происходит:

* Подсчитывается размер байтов, необходимы для размещения объекта
* Прибавляет к полученному значению размер системных полей это указатель на тип объекта и индекс блока синхронизации
* Проверяет хватает ли памяти для создания объекта. Если хватает, то для ему выделяется память, начиная с адреса указателя. Затем создается объект и возвращается ссылка на него. Меняет адрес указателя, на первый адрес после созданного объекта.

### Алгоритм сборки мусора

Когда CLR запускает сборку мусор, она сначало приостанавливает все потоки. Тем самым приостанавливая обращения к объектам и предотвращения изменения их состояния. Затем переходит к этапу маркировки объектов. CLR перебирает все активные корни объекта, если объекты имеют корни, значит они используются, такие объекты переживут сборку мусора. Объекты которые не используются будут удалены.
После процесса удаления CLR производит фрагментацию памяти, и устанавливает указатель.
Если CLR не удается высовободить память и свободной памяти не остается, то при создании нового объекта выкидывает исключение OutOfMemoryException. Перед этим CLR всегда производит сборку.

### Поколения

Сборщик мусора поддерживает поколения объектов, это увеличивает эффективность сборки. Всего существует 3 поколения от нулевого до вторго, поколения работают на следующих правилах.

* Чем младше объект, тем меньше поколение
* Чем старше объект, тем длиннее его время жизни
* Сборка мусора в части кучи производится быстрее, чем во всей куче

При инициализации CLR выбирает пороговй размер для поколения 0. Если в результате выделения памяти для нового объекта размер поколения 0 превышает пороговое значение, должна начаться сборка мусора. После сборки мусора, в поколении 0 не остается объектов, то есть объекты пережившие сборку мусора переходят в поколение 1. Новые объекты снова начинают заполнять 0 поколение. Первое поколение не будет проверяться сборщиком мусора пока оно не привысит пороговое значение, если поколение 1 превышает пороговое значение, то сборщик проверяет объекты и в нем. Выжившие объекты поколения 1 перемещаются в поколение 2. Обычно при высвобождении поколения 1 очищается большой объем памяти.

### Большие объекты

Помимо управляемой кучи, существуе еще куча для больших объекто (large object heap), CLR считает большие объекты размером более 85 000 байт (!!! это значение может меняться в зависимости от версии языка). С такими объектами CLR работает иначе:

* Они всегда относятся к поколению 2
* К большим объектам не применяется сжатие
* Паямять для них выделяется в отдельном адресном пространстве

## Программное управление сборщиком мусора

[класс GC](http://msdn.microsoft.com/ru-ru/library/system.gc.aspx)

Для ручного управления сборкой существуетклас `System.GC` (Garbache collector). Не рекомендуется ручное управление сборщиком

## Очистка неуправляемых ресурсов

[Неуправляемы ресурсы](https://docs.microsoft.com/ru-ru/dotnet/standard/garbage-collection/unmanaged)

Для удаления объектов которые взаимодействую с неуправляемыми ресурсами (такие как подключения к бд, взаимодействие сфаиловой системой, tcp соединения и др)необходимо реализовать интерфейс IDisposable и паттерн высвобождения.

### Деструктор

```c#
class MyClass
{
    // Деструктор(или методы Финализаторы)
    // Деструкторы не могут вызываться явно в С#, они не наследуются. 
    // Класс может иметь только один деструктор.
    // Когда вызывается финализатор объекта, то вызывается каждый финализатор в цепочке наследования — от последнего к первому.    
    // Выполняются в отдельном  потоке CLR. 
    ~MyClass()
    {
        Console.WriteLine("Hello, From destructor");
    }
}
```
