# Базовый класс Object

Все классы неявно унаследованы от общего класса `Object` который содержит в себе 5 открытых методов и 1 защищенный метод

Открытые методы:

* static bool Equals(Object objA, Object objB) - статический метод для сравнения объектов.
* static bool ReferenceEquals(Object objA, Object objB) - статический метод для сравнения объектов по ссылке, используется если переопределен виртуальный метод Equals, и нужно сравнить объекты по ссылке.
* Type GetType() - возвращает тип объекта.
* virtual bool Equals(Object objA) - сравнивает текущий объект с указанным. При переопределении Equals нужно переопределить метод GetHashCode.
* virtual int GetHashCode() - хэш-функция по умолчанию. Хэш функции нужны для работы с словарей и хэш-таблиц.
* virtual string ToString() - строковое представление объекта.

Защищенный метод:

* Object MemeberwiseClone() - позволяет создать поверхностную копию (shallow)

```c#
class MyClass // : Object - каждый класс не явно унаследован от Object
{
    public string Name { get; set; }    

    // По умолчанию выведет полное имя класс (namespace.Имя_класса)
    public override string ToString()
    {
        return string.Format($"{Name} {Age}");
    }
    
    // По умолчанию сравнивает объекты по ссылке
    public override bool Equals(object obj)
    {
        if (obj != null && obj is MyClass)
        {
            MyClass mc = (MyClass)obj;
            if (mc.Name == this.Name)
                return true;

            return false;
        }

        return false;
    }

    // При переопределении Equals нужно переопределить GetHashCode
    public override int GetHashCode()
    {
        return this.ToString().GetHashCode();
    }

    // Неполная копия объекта
    public MyClass Clone()
    {
        return (MyClass)this.MemberwiseClone();
    }
}
```

## Из чего состоит объект

У каждого объекта ссылочного типа есть так называемый заголовок (Header), который состоит из двух полей: указатель на тип которым является данный объект (MethodTablePointer), а так же индекс синхронизации (SyncBlockIndex)

Первое поле необходимо для того, чтобы каждый управляемый объект мог предоставить информацию о своем типе во время выполнения, то есть нельзя выдать один тип за другой, это сделано для безопасности типов. Так же этот указатель используется для реализации динамической диспетчеризации методов, фактически через него вызываются методы данного объекта. Метод Object.GetType фактически возвращает именно указатель MethodTablePointer.

Второе поле необходимо для многопоточного окружения, а именно для того чтобы каждый объект можно было использовать потокобезопасно.

Когда загружается CLR, она создает так называемый пул блоков синхронизации, можно сказать обычный массив этих блоков синхронизации. Когда объекту необходимо работать в многопоточном окружении (это делается с помощью метода Monitor.Enter или конструкции языка C# lock), CLR отыскивает свободный блок синхронизации в своем списке и записывает его индекс в то самое поле в заголовке объекта. Как только объект перестает нуждаться в многопоточном окружение, CLR просто присваивает значение -1 этому полю и тем самым освобождает блок синхронизации.

## GetHashCode

Хэш-код — это числовое значение, которое используется для вставки и задания объекта в коллекции на основе хэша, такой как Dictionary<TKey,TValue> класс, Hashtable класс или тип, производный от DictionaryBase класса. GetHashCodeМетод предоставляет этот хэш-код для алгоритмов, требующих быстрых проверок равенства объектов.

Два объекта, которые равны, возвращают хэш-коды, равные. Однако обратная неверно: равные хэш-коды не подразумевают равенство объектов, так как разные (неравные) объекты могут иметь одинаковые хэш-коды. более того, .net не гарантирует реализацию метода по умолчанию GetHashCode , а значение, возвращаемое этим методом, может отличаться между реализациями .net, такими как разные версии платформа .NET Framework и .net Core, и платформы, такие как 32-разрядная и 64-разрядные платформы. По этим причинам не следует использовать реализацию этого метода по умолчанию в качестве уникального идентификатора объекта для хэширования. Ниже приведено два последствия.

Не следует рассчитывать, что равные хэш-коды подразумевают равенство объектов.

Никогда не следует сохранять или использовать хэш-код вне домена приложения, в котором он был создан, так как один и тот же объект может быть хэширован между доменами приложений, процессами и платформами.

Хэш-код предназначен для эффективной вставки и уточняющего запроса в коллекциях, основанных на хэш-таблице. Хэш-код не является постоянным значением. По этой причине:

1. Не сериализуются значения хэш-кода или не сохраняйте их в базах данных.
2. Не используйте хэш-код в качестве ключа для получения объекта из коллекции с ключом.
3. Не отправляйте хэш-коды между доменами приложений или процессами. В некоторых случаях хэш-коды могут быть вычислены отдельно для каждого процесса или домена приложения.
4. Не используйте хэш-код вместо значения, возвращаемого криптографической функцией хэширования, если требуется криптографический надежный хэш. Для криптографических хэшей используйте класс, производный от System.Security.Cryptography.HashAlgorithm класса или System.Security.Cryptography.KeyedHashAlgorithm .
5. Не проверяйте равенство хэш-кодов, чтобы определить, равны ли два объекта. (Неравные объекты могут иметь идентичные хэш-коды.) Чтобы проверить равенство, вызовите ReferenceEquals Equals метод или.
