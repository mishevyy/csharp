# Наследование

Наследование механизм ООП позволяющий описать новый класс на основе уже существующего при этом функциональность базового класса заимствуется новым производным классом.

Для того что-бы наследоваться от класса нужно поставит `:` и написать имя класса от которого хотим наследоваться. У производного класса уровень доступа должен быть таким же как у класса родителя или более строгий.

```c#
class BaseClass {}

class DerivedClass : BaseClass{}
```

_Ключевое слово `sealed` - запрещает наследование от класса_

```c#
sealed class MyClass { }
```

## Наследование и уровни доступа (Модификаторы доступа)

* public - (открытый) доступ возможен из любого другого кода в той же сборке или другой сборке, ссылающейся на него
* private - (закрытый) доступ к типу или члену можно получить только из кода в том же классе или структуре
* protected - (защищенный) доступ к элементу можно получить только из кода в том же классе или структуре, либо в производном классе в любой сборке
* internal - доступ к члену или типу возможен из любого другого кода в той же сборке
* protected internal - доступ к типу или члену возможен из любого другого кода в той же сборке, в другой сборке доступ к элементу можно получить только из кода в том же классе или структуре, либо в производном классе
* private protected - доступ к элементу можно получить только из кода в том же классе или структуре, либо в производном классе в той же сборке

## Виртуальные члены и их переопределение

Ключевые слова:

* virtual - поля и методы помеченные этим словом возможно переопределить в классе наследнике
* override - переопределяет члены базового класса, для этого они должны быть помечены как virtual
* sealed - запрещает дальнейшее переопределение члена, для этого они должны быть помечены как virtual
* new - замещает реализацию из класса наследника

## Override и New

Если член переопределен в наследнике, то его реализация будет использовать в случае создания класса наследника и в случае когда наследник приводится к базовому классу. Замещенные методы принадлежат только конкретному классу.

```c#
class BaseClass
{
    public string Name { get; set; }
    public int Age { get; set; }

    // Конструктор по умолчанию обязателен при наследовании от базоваого класса, 
    // если есть пользовательский конструктор,
    // и в наследуемом классе необходимо использовать конструктор по умолчанию.
    public BaseClass()
    {
        Console.WriteLine("BaseClass .ctor");
    }

    public BaseClass(string name, int age)
    {
        this.Name = name;
        this.Age = age;
    }

    public virtual void Method1()
    {
        Console.WriteLine("Method1 from BaseClass");
    }

    public virtual void Method2()
    {
        Console.WriteLine("Method2 from BaseClass");
    }

    public virtual void Method3()
    {
        Console.WriteLine("Method3 from BaseClass");
    }

    public virtual void Method4()
    {
        Console.WriteLine("Method4 from BaseClass");
    }
}
```

```c#
class DerivedClass : BaseClass
{
    public string DerivedProprty { get; set; }

    // Пользовательский конструктор.
    // При создании объекта производного класса, конструктор производного класса 
    // автоматически вызывает конструктор по умолчанию из базового класса.
    // Конструктор базового класса, присвоит всем данным какие-то свои безопасные значения.
    // После этого начнет работу конструктор производного класса, который повторно
    // будет определять значения для унаследованых членов. (ДВОЙНАЯ РАБОТА)!

    // Для избежания этого, нужно вызывать конструктор из базового класса, 
    // с помощбю ключевого слова base
    // Вызывается пользовательский конструктор базового класса, при этом не нужно, 
    // присваивать значения, унаследованным членам в конструкторе производного класса.
    public DerivedClass(string derivedProp, string name, int age) : base(name, age)
    {
        this.DerivedProprty = derivedProp;
    }

    // override - переопределяет метод базового класса, для этого
    // метод в базовом классе должен быть определен как virtual
    public override void Method1()
    {
        Console.WriteLine("Method1 from DerivedClass");
    }

    // base - вызывает реализацию метода из базового класса
    public override void Method2()
    {
        base.Method2();
    }

    // Ключевое слово new - замещает метод из базового класса
    // таким образом, что метод в класс наследнике не имеет ничего общего с класом родителем
    public new void Method3()
    {
        Console.WriteLine("Method3 from DerivedClass");
    }

    // Ключевое слово sealed запрещает дальнейшее переопределение метода
    public override sealed void Method4()
    {
        Console.WriteLine("Method4 from DerivedClass");
    }
}
```
