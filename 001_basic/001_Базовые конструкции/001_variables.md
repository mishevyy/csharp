# Переменные

*Переменная (Variable) - область памяти, которая хранит в себе некоторое значение, которое можно изменить.*

```c#
int i = 5;
```

*Константа (Constant) - область памяти, которая хранит в себе некоторое значение, которое нельзя изменить.*
*Константы определяются на уровне компилятора.*

```c#
const double pi = 3.14;
```

### Оператор `sizeof`

Позволяет получить размер значения в байтах для указанного типа.
Оператор `sizeof` можно применять только к типам: **byte, sbyte, short, ushort, int, uint, long, ulong, float, double, decimal, char, bool.** Возвращаемые оператором `sizeof` значения имеют тип int.

```c#
int byteSize = sizeof(byte);
```

### Литерал `default`

Устанавливает переменной значение по умолчанию для ее типа данных.

```c#
int idef = default;
```

### Неявно типизированные локальные переменные `var`

Тип переменной устанавливается компилятором, во время компиляции. По своей сути `var` является синтаксическим сахаром, и при компиляции превращается в тот тип, который необходим.

* Неявно типизированные локальные переменные не допускают множественного объявления.
* Неявно типизированные локальные переменные должны быть инициализированы.
* Константа не может быть неявно типизированная.

```c#
var myVariable = 7;
```

### Операторы Инкремента и Декремента

```c#
// Постфиксный инкремент (Post-increment).
// Сначала действие, потом увеличение переменной на 1.
Console.WriteLine(number++);

// Префиксный инкремент (Pre-increment).
// Сначала увеличение переменной на 1, потом действие.
Console.WriteLine(++number); 
```

```c#
// Постфиксный декремент (Post-decrement).
// Сначала действие, потом уменьшение переменной на 1.
Console.WriteLine(number--); 

// Префиксный декремент (Pre-decrement).
// Сначала уменьшение переменной на 1, потом действие.
Console.WriteLine(--number);
```

## Преобразование типа

*Преобразование типа (Casting или Type conversion) - это преобразование значения переменной одного типа в значение другого типа.* Выделяют `явное (explicit)` и `неявное (implicit)` преобразование типов.

### Явное (опасное) преобразование типа

Явное преобразование значения типа - int в тип byte.
(преобразование большего типа в меньший, приводит к потере части результата)

```c#
int e = 256;    //  0000 0000   0000 0000   0000 0001   0000 0000  -  4 байта
byte f = 0;     //                                      0000 0000  -  1 байт
f = (byte)e;    //                                      0000 0000  -  1 байт
// f = e;       // ОШИБКА.
```

Явное преобразование значения типа - float в тип int. (преобразование вещественного типа в целый, приводит к потере точности результата)

```c#
float g = 10.5f;
int h = 0;
h = (int)g;
// h = g;           // ОШИБКА.
```

### Неявное (безопасное) преобразование

Неявное преобразование значения типа - byte в тип int. (преобразование меньшего типа в больший)

```c#
byte a = 10;     //                                      0000 1010  -  1 байт
int b = 0;       //  0000 0000   0000 0000   0000 0000   0000 0000  -  4 байта
b = a;           //  0000 0000   0000 0000   0000 0000   0000 1010  -  4 байта 
```

Неявное преобразование значения типа - int в тип float. (преобразование целого типа в вещественный)

```c#
int c = 255;
float d = 0f;
d = c;
```

### Кастинг констант

Возможно неявное преобразование значения константы типа - int в тип byte, при инициализации переменной значением константы, если значение константы не превышает максимально допустимого значения переменной.

```c#
const int i = 255;  //  0000 0000   0000 0000   0000 0000   1111 1111  -  4 байта
byte j = 0;         //                                      0000 0000  -  1 байт
j = i;              //                                      1111 1111  -  1 байт
```

Возможно явное преобразование значения константы типа - float в тип byte, при инициализации переменной значением константы, если значение константы не превышает максимально допустимого значения переменной.

```c#
const float k = 255;
byte l = 0;
l = (byte)k;
```

Невозможно ни явное, ни неявное преобразование значения константы, при инициализации переменной значением константы, если значение константы превышает максимально допустимый диапазон значения переменной.

```c#
const int m = 256;  //  0000 0000   0000 0000   0000 0001   0000 0000  -  4 байта
byte n = 0;         //                                      0000 0000  -  1 байт
// n = m;           //  ОШИБКА.
// n = (byte)m;     //  ОШИБКА.
```

Невозможно ни явное, ни неявное преобразование значения вещественной константы, при инициализации целочисленной переменной значением константы, если значение константы превышает максимально допустимый диапазон значения переменной.

```c#
const float o = (float)256.5; // преобразование double в float
byte p = 0;
// p = o;           //  ОШИБКА.
// p = (byte)o;     //  ОШИБКА.
```

### Проверка переполнения

**Настройка проверки переполнения типа в проекте.**
Свойства проекта -> Сборка -> Дополнительно.
Поставить (убрать) флаг - Проверять арифметическое переполнение

```c#
sbyte a = 127;

// Проверка переполнения - (checked)
checked
{
    a++; // ОШИБКА уровня компилятора
}

// Запрет проверки переполнения - (unchecked)
unchecked
{
    a++; // Логическая ошибка
}
```

## Пустые переменные

Пустая переменная представляет собой доступную только для записи переменную с именем `_` (знак подчеркивания). Вы можете назначить одной переменной все значения, которые не потребуются в дальнейшем. Пустая переменная является аналогом не присвоенной переменной и не может использоваться в коде где-либо, за исключением оператора присваивания.

Пустые переменные поддерживается в следующих случаях.

* При деконструкции кортежей или пользовательских типов.

  ```c#
  var (_, pop, _) = QueryCityData("New York City");
  ```

* При вызове методов с параметрами [out](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/out-parameter-modifier).

* В операции сопоставления шаблонов с помощью [оператора `is`](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/is) и [оператора `switch`](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/statements/selection-statements#the-switch-statement).

* В качестве автономного идентификатора в тех случаях, когда требуется явно идентифицировать значение присваивания как пустую переменную.

  ```c#
  _ = res == null ? res = 100 : res;
  ```

## Усовершенствования в синтаксисе числовых литералов

Неправильное толкование числовых констант затрудняет понимание кода при первом прочтении. Битовые маски или другие символьные значения могут вызывать затруднения. C# 7.0 содержит две новые возможности для записи чисел в удобочитаемом виде: *двоичные литералы* и *разделители цифр*.

```c#
public const int Sixteen =   0b0001_0000;
public const int ThirtyTwo = 0b0010_0000;
public const int SixtyFour = 0b0100_0000;
public const int OneHundredTwentyEight = 0b1000_0000;
public const long BillionsAndBillions = 100_000_000_000;
```
