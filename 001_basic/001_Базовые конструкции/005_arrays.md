# Массивы

Массив представляет собой механизм, позволяющий рассматривать набор элементов как единую коллекцию.
CLR поодерживает одномерные , многмерные массивы и нерегулярные массивы.

Базовым типом для всех массивов является абстрактный класс `Array`, это значит что массивы всегда относятся к ссылочному типу, а переменная содержит не элементы масива, а ссылку на массив. Так же массив помимо элементов массива, хранит в себе информацию о размерности и типе элементов.

## Одномерный массив

```c#
int[] stuff = new int[10];
for (int i = 0; i < stuff.Length; i++)
{
    stuff[i] = i;
}
```

## Двухмерный массив

```c#
int[,] stuff = new int[5, 10];
for (int i = 0; i < 5; i++)
{
    for (int k = 0; k < 10; k++)
    {
        stuff[i, k] = 10;
    }
}
```

## Трехмерный массив

```c#
int[,,] stuff = new int[4, 4, 4];
for (int x = 0; x < 4; x++)
{
    for (int y = 0; y < 4; y++)
    {
        for (int z = 0; z < 4; z++)
        {
            stuff[x, y, z] = x + y + z;
        }
    }
}
```

## Зубчатый массив (jagged array)

```c#
int[][] jagged = new int[3][];
jagged[0] = new int[] { 1, 2 };
jagged[1] = new int[] { 1, 2, 3, 4, 5 };
jagged[2] = new int[] { 1, 2, 3 };

// Во внешнем цикле выполняется проход по всем вложенным массивам.
for (int i = 0; i < jagged.Length; ++i)
{
    // Во внутреннем цикле выполняется обращение к каждому элементу вложенного массива.
    for (int j = 0; j < jagged[i].Length; ++j)
    {
        Console.Write("{0} ", jagged[i][j]);
    }
    Console.Write("\n");
}
```

## Ковариантность массивов

Массивы поддерживают ковариантность, то есть массив элементов производного типа, можно привести к массиву элементов базового типа.

```c#
class A {}
class B : A {}

B[] array = new B[]
{
    new B(),
    new B(),               
};

Foo(array);

void Foo(A[] stuff){} 
```

## Индексы и диапазоны (нововведение с# 8.0)

Диапазоны и индексы обеспечивают лаконичный синтаксис для доступа к отдельным элементам или диапазонам в последовательности.

Поддержка языков опирается на два новых типа и два новых оператора:

- [System.Index](https://docs.microsoft.com/ru-ru/dotnet/api/system.index) представляет индекс в последовательности.
- Оператор `^` (индекс с конца), который указывает, что индекс указан относительно конца последовательности.
- [System.Range](https://docs.microsoft.com/ru-ru/dotnet/api/system.range) представляет вложенный диапазон последовательности.
- Оператор диапазона `..`, который задает начало и конец диапазона в качестве своих операндов.

Начнем с правил для использования в индексах. Рассмотрим массив `sequence`. Индекс `0` совпадает с `sequence[0]`. Индекс `^0` совпадает с `sequence[sequence.Length]`. Обратите внимание, что `sequence[^0]` создает исключение так же, как и `sequence[sequence.Length]`. Для любого числа `n` индекс `^n` совпадает с `sequence.Length - n`.

Диапазон указывает *начало* и *конец* диапазона. Начало диапазона является включающим, но конец диапазона является исключающим, то есть *начало* включается в диапазон, а *конец* не включается. Диапазон `[0..^0]` представляет весь диапазон так же, как `[0..sequence.Length]` представляет весь диапазон.

```c#
int[] nt = temperatures[1..4]; - Range (..)
int[] nt = temperatures[^2]; - Index
string[] people = { "Tom", "Bob", "Sam", "Kate", "Alice" };
string[] peopleRange = people[..];		// Все элементы
string[] peopleRange = people[1..];		// Bob, Sam, Kate, Alice (Со 2 по последний)
string[] peopleRange = people[1..4];	// Bob, Sam, Kate (Со 2 по 3 включительно)
string[] peopleRange = people[..4];		// Tom, Bob, Sam, Kate (с 1 по 3 включительно)
string[] peopleRange = people[^2..];       // два последних - Kate, Alice
string[] peopleRange = people[..^1];       // начиная с предпоследнего - Tom, Bob, Sam, Kate
string[] peopleRange = people[^3..^1];     // два начиная с предпоследнего - Sam, Kate
```

Также можно объявить диапазоны как переменные:

```c#
Range phrase = 1..4;
string[] peopleRange = people[phrase];
```

## Структура Span<T> (нововведение с# 8.0)

[Структура Span](https://docs.microsoft.com/ru-ru/dotnet/api/system.span-1?view=net-5.0)
Span позволяет работать с памятью более эффективно и избежать ненужных выделений памяти. 
Так, используем вместо массивов Span:

```c#
int[] temperatures = new int[]
{
    10, 12, 13, 14, 15, 11, 13, 15, 16, 17,
    18, 16, 15, 16, 17, 14,  9,  8, 10, 11,
    12, 14, 15, 15, 16, 15, 13, 12, 12, 11
};
Span<int> temperaturesSpan = temperatures;
Span<int> firstDecade = temperaturesSpan.Slice(0, 10);    // нет выделения памяти под данные
Span<int> lastDecade = temperaturesSpan.Slice(20, 10);    // нет выделения памяти под данные
```

Для создания производных объектов Span применяется метод Slice, который из Spana выделяет часть и возвращает ее в виде другого объекта Span. 
Теперь объекты Span firstDecade и lastDecade работают с теми же данными, что и temperaturesSpan, а дополнительно память не выделяется.
То есть во всех трех случаях мы работаем с тем же массивом temperatures. Мы даже можем в одном Span изменить данные, и данные изменятся в другом:

Span < T > — Это структура ссылки , которая выделяется в стеке, а не в управляемой куче. Типы структур ref имеют ряд ограничений,  чтобы гарантировать, что их нельзя повысить до управляемой кучи, в том числе что они не могут быть упакованы, они не могут быть назначены переменным типа Object dynamic или любому типу интерфейса, они не могут быть полями в ссылочном типе и не могут использоваться в await и в yield границах. Кроме того, вызовы двух методов Equals(Object) и GetHashCode вызывают исключение NotSupportedException.
