# Задания

Задания решают две основные проблемы, которые сущесвуют при использовании объектов Thread и ThreadPol. Это возможность узнать о завершении операции и получить возвращаемое значение.
Для создания задания следует вызвать конструктор и перадать ему делегат Action или Func. Так же при желании можно передать в конструктор перечисление TaskCreationOptions, кправляющее способами выполнения заданий. Эти возможно реализованы в библиотеке TPL.
Библиотека параллельных задач (TPL) представляет собой набор открытых типов и API-интерфейсов в пространствах имен System.Threading и System.Threading.Tasks.
В библиотеке параллельных задач осуществляется секционирование работы, планирование потоков в пуле ThreadPool, поддержка отмены, управление состоянием и выполняются другие низкоуровневые задачи. Используя библиотеку параллельных задач, можно повысить производительность кода, сосредоточившись на работе, для которой предназначена программа.

## Создание задачи

```c#
static void Main()
{
    // Следующиие строки эквивалентны
    // Task использует ThreadPool для создания задач

    //ThreadPool.QueueUserWorkItem(ComputeBoundOp, 5);

    //Task t = new Task(ComputeBoundOp, 5);
    //t.Start();

    Task.Run(() => ComputeBoundOp(5));
    Console.WriteLine("g");
}

static void ComputeBoundOp(object? state) // Метод выполняемый выделеным потоком
{
    Console.WriteLine("In ComputeBoundOp: state={0}", state);
    Thread.Sleep(1000);

    // После возвращения методом работы выделеный поток завершается
}
```

TaskCreationOptions

```c#
 // По умолчанию
TaskCreationOptions.None 

// Сообщает планировщику, что задание должно быть поставлено на выполнение по возможности скорее
TaskCreationOptions.PreferFairness

// Сообщает планировщику, что ему следует более активно создавать потоки в пуле потоков.
TaskCreationOptions.LongRunning 

// Всегда учитывается: присоединяет задание к его родителю
TaskCreationOptions.AttachedToParent 

// Если задача пытается присоединиться к родительской задаче, она интерпретируется как обычная, а не как дочерняя задача.
TaskCreationOptions.DenyChildAttach

// Заставляет дочерние задачи использовать планировщик по умолчанию вместо родительского планировщика.
TaskCreationOptions.HideScheduler 

TaskCreationOptions.RunContinuationsAsynchronously 
```

Что бы узнать в каком статусе находится задача можно обратится к ее свойству Status

```c#
 Task<int> task = new Task<int>(n => Sum((int)n), 10_000); //1000000000
 Console.WriteLine("Task status is: " +  task.Status);   
```

## Завершение задания и получение результата

Если вычислительное задание генерирует необработанное исключение, оно поглащается и сохраняется в коллекции, а поток разрешается вернуть в пул.
Затем после вызова метода Wait или свойству Result эти члены выбросят исключение System.AggregateException. AggregateException инкапсулирует коллекцию этих исключений.

Если вы ни разу не вызывали методы Wait или Result и не обращались к свойству Exception класса Task, код не «узнает» о появившихся исключениях.

```c#
static void Main()
{
    Task<int> t = new Task<int>(n => Sum((int)n), 10_000); //1000000000

    t.Start();

    // Явное ожидание завершения потока
    // t.Wait(); 

    Console.WriteLine("The Sum is: " + t.Result);
}

static int Sum(int n)
{
    int sum = 0;
    for(; n > 0; n--)
    {
        checked
        {
            sum += n;
        }
    }
    return sum;
}
```

## Отмена задания

Для отмены задания используется все тот же объект CancellationTokenSource. Однако при отмене задания генерируется исключение OperationCancelationException. Причиной исключения становится тот факт, что в отличии от ThreadPool, задания поддерживают концецию выполнения и могут возвращать значения. Следовательно нужен способ отличить завершенное задание от незавершенного.

```c#
static void Main()
{
    CancellationTokenSource cts = new CancellationTokenSource();

    Task<int> t = new Task<int>(n => Sum(cts.Token, (int)n), 10_000); //1000000000

    t.Start();
    cts.Cancel();

    //t.Wait(); // Явное ожидание завершения потока

    try
    {
        Console.WriteLine("The Sum is: " + t.Result);
    }        
    catch (AggregateException x)
    {
        x.Handle(e => e is OperationCanceledException);

        Console.WriteLine("Sum was canceled");
    }
}

static int Sum(CancellationToken ct, int n)
{
    int sum = 0;
    for (; n > 0; n--)
    {
        ct.ThrowIfCancellationRequested();

        checked
        {
            sum += n;
        }
    }
    return sum;
}
```

## Автоматический запуск задания по завершению предыдущего

Для написания масштабируемого программного обеспечения следует избегать блокировки потоков. Вызов метода Wait или запрос свойства Result при незавершенном задании приведет, скорее всего, к появлению в пуле нового потока, что  увеличит расход ресурсов и отрицательно скажется на расширяемости. К счастью, существует способ узнать о завершении задания. Оно может просто инициировать выполнение следующего задания.

```c#
static void Main()
{
    Task<int> t = Task.Run(() => Sum(CancellationToken.None, 10_000));

    Task cwt = t.ContinueWith(task => Console.WriteLine("The sum is: " + task.Result), TaskContinuationOptions.OnlyOnRanToCompletion);

    t.ContinueWith(task => Console.WriteLine("Sum threw: " + task.Exception), TaskContinuationOptions.OnlyOnFaulted);
    t.ContinueWith(task => Console.WriteLine("Sum was canceled"), TaskContinuationOptions.OnlyOnCanceled);

    Console.ReadLine();
}

static int Sum(CancellationToken ct, int n)
{
    int sum = 0;
    for (; n > 0; n--)
    {
        ct.ThrowIfCancellationRequested();

        checked
        {
            sum += n;
        }
    }
    return sum;
}
```

### Дочерние задания

```c#
// Дочерние задания
Task<int[]> parent = new Task<int[]>(() =>
{
    var results = new int[3];

    new Task(() =>results[0] = Sum(CancellationToken.None, 10_000), TaskCreationOptions.AttachedToParent).Start();
    new Task(() =>results[1] = Sum(CancellationToken.None, 20_000), TaskCreationOptions.AttachedToParent).Start();
    new Task(() =>results[2] = Sum(CancellationToken.None, 30_000), TaskCreationOptions.AttachedToParent).Start();

    return results;
});

parent.ContinueWith(parentTask => Array.ForEach(parentTask.Result, Console.WriteLine));

parent.Start();
```

## Фабрики заданий

Иногда возникает необходимость получить набор объектов Task, находящихся в одном и том же состоянии. Для этого не нужно раз за разом передавать одни и те же параметры в конструктор каждого задания, достаточно создать фабрику заданий.

```c#
static void Main()
{
    Task parent = new Task(() =>
    {
        var cts = new CancellationTokenSource();

        var tf = new TaskFactory<int>(cts.Token,
            TaskCreationOptions.AttachedToParent,
            TaskContinuationOptions.ExecuteSynchronously,
            TaskScheduler.Default);

        var childTask = new[]
        {
            tf.StartNew(() =>Sum(cts.Token, 10_000)),
            tf.StartNew(() =>Sum(cts.Token, 20_000)),
            tf.StartNew(() =>Sum(cts.Token, int.MaxValue)), // Для генерации исключения
        };

        for (int t = 0; t < childTask.Length; t++)
        {
            childTask[t].ContinueWith(t => cts.Cancel(), TaskContinuationOptions.OnlyOnFaulted);
        }

        tf.ContinueWhenAll(childTask,
            completeTask => completeTask
                .Where(t => !t.IsFaulted && !t.IsCanceled)
                .Max(t => t.Result), CancellationToken.None)
            .ContinueWith(t => Console.WriteLine("The maximum is: " + t.Result), TaskContinuationOptions.ExecuteSynchronously);

    });

    parent.ContinueWith(p =>
    {
        StringBuilder sb = new StringBuilder("The following exception(s) occurred:" + Environment.NewLine);

        foreach (var ex in p.Exception.Flatten().InnerExceptions)
        {
            sb.Append(" " + ex.GetType().ToString());
        }

        Console.WriteLine(sb.ToString());

    }, TaskContinuationOptions.OnlyOnFaulted);

    parent.Start();

    Console.ReadLine();
}

static int Sum(CancellationToken token, int n)
{
    int sum = 0;
    for (; n > 0; n--)
    {
        token.ThrowIfCancellationRequested();
        checked
        {
            sum += n;
        }
    }
    return sum;
}
```

### Периодические вычислительные операции

В пространстве имен System.Threading определен класс Timer, который позволяет периодически вызывать методы из пула потоков. Создавая экземпляр этого класса, вы сообщаете пулу, что вам нужен метод, ратный вызов которого должен быть выполнен в заданное время.

```c#
class Program
{
    private static Timer s_timer;
    static void Main()
    {
        Console.WriteLine("Checking status every 2 seconds");

        s_timer = new Timer(Status, null, Timeout.Infinite, Timeout.Infinite);
        s_timer.Change(0, Timeout.Infinite);

        Console.ReadLine();
    }

    static void Status(object? state)
    {
        Console.WriteLine("In Status at {0}", DateTime.Now);
        Thread.Sleep(1000);

        s_timer.Change(2000, Timeout.Infinite);
    }
}   
```
